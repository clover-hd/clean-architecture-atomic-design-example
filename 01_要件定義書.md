# ECサイト学習プロジェクト 要件定義書

**文書番号**: REQ-001
**作成日**: 2025-09-18
**バージョン**: 2.0

---

## 1. プロジェクト概要・背景・目的

### 1.1 プロジェクト概要
本プロジェクトは、モダンなWebアプリケーション開発における**クリーンアーキテクチャ**、**アトミックデザイン**、**TypeScript型システム**の習得を主目的とした学習特化型ECサイト開発プロジェクトです。

### 1.2 プロジェクト背景
- 複雑なフレームワークに依存せず、基本的な技術スタックで設計原則を学習する必要性
- 実際のビジネスドメイン（ECサイト）を通じて、実践的なアーキテクチャパターンを習得する需要
- 段階的な学習進行を可能にする、拡張性を考慮した設計手法の必要性

### 1.3 プロジェクト目的
**主目的**: クリーンアーキテクチャ、アトミックデザイン、TypeScript型システムの実践的習得
**副目的**: Express.js、EJS、SQLiteをTypeScriptで実装するMVCパターンの理解深化
**最終目標**: 型安全性・保守性・拡張性・テスタビリティを兼ね備えた設計手法の体得

---

## 2. 学習目標と成功指標

### 2.1 技術的学習目標

#### 🎯 クリーンアーキテクチャ習得目標
- **依存関係逆転原理**の理解と実装
- **関心の分離**による責務明確化
- **テスタビリティ**を考慮した設計
- **4層アーキテクチャ**（Presentation, Application, Domain, Infrastructure）の実装

#### 🎨 アトミックデザイン習得目標
- **Atoms（原子）**: 最小単位のUIコンポーネント設計
- **Molecules（分子）**: 機能単位の組み合わせ設計
- **Organisms（有機体）**: 複雑なUI領域の構成
- **Templates（テンプレート）**: ページレイアウト設計
- **Pages（ページ）**: 完成されたページ実装

#### 🛠️ Express MVC習得目標
- **Router**: URLパターンとController連携
- **Controller**: HTTPリクエスト処理とフロー制御
- **Model**: EntityとビジネスロジックによるModel実装
- **View**: EJSテンプレートシステムの活用

#### ⚡ TypeScript習得目標
- **型安全性**: コンパイル時エラー検出によるバグ予防
- **Interface設計**: 契約ベースの設計とドメインモデリング
- **Generic型**: 再利用可能な型安全コンポーネント設計
- **型駆動開発**: 型定義から始まる設計アプローチ
- **高度な型**: Utility Types、Conditional Types の活用
- **静的解析**: 型システムを活用した品質管理

### 2.2 定量的成功指標
- **アーキテクチャ準拠率**: 95%以上（4層分離、依存関係方向準拠）
- **コンポーネント再利用率**: 80%以上（Atomic Design階層での再利用）
- **型カバレッジ**: 90%以上（TypeScript型定義の網羅性）
- **テストカバレッジ**: 各層で70%以上（特にDomain層は90%以上）
- **コンパイルエラーゼロ**: タイプエラーが発生しない型安全なコード
- **関心分離度**: Controller、UseCase、Entity、Repositoryの責務明確度

### 2.3 定性的成功指標
- クリーンアーキテクチャの原則に基づいた設計判断ができる
- アトミックデザインによるコンポーネント階層を構築できる
- **型駆動設計思考**: ドメインモデルを型で表現し、型安全性を活用した設計ができる
- **Interface設計能力**: 適切な抽象化と契約ベースの設計ができる
- ビジネスロジックとインフラストラクチャの独立性を保持できる
- **静的解析活用**: TypeScriptの型システムを活用した品質管理ができる
- 変更容易性と拡張性を考慮した型安全な実装ができる

---

## 3. 機能要件

### 3.1 必須機能（コア学習対象）

#### 3.1.1 商品表示機能
- **商品一覧表示**: ページネーション、基本的なフィルタリング
- **商品詳細表示**: 商品情報、画像、在庫状況表示
- **商品検索**: タイトル・説明文による簡易検索

#### 3.1.2 ショッピングカート機能
- **カート商品追加**: 商品詳細から数量指定でカート追加
- **カート内容表示**: 商品一覧、数量、小計表示
- **カート商品編集**: 数量変更、商品削除
- **カート総額計算**: 商品合計、税込み金額計算

#### 3.1.3 注文処理機能
- **注文情報入力**: 配送先情報、連絡先情報入力
- **注文確認**: 注文内容確認、最終価格表示
- **注文確定**: 注文データ生成、完了画面表示

#### 3.1.4 ユーザー管理機能
- **ユーザー登録**: 基本情報入力、重複チェック
- **ログイン・ログアウト**: セッション管理、認証状態維持
- **プロフィール管理**: 個人情報編集、パスワード変更
- **注文履歴表示**: 過去の注文情報表示

#### 3.1.5 管理者機能
- **商品管理**: 商品登録、編集、削除、在庫管理
- **注文管理**: 注文一覧、ステータス更新
- **ユーザー管理**: ユーザー一覧、基本的な操作

### 3.2 オプション機能（学習進度に応じて）
- **商品カテゴリ**: カテゴリ別商品表示
- **商品レビュー**: 簡易レビュー機能
- **メール通知**: 注文完了メール（学習用）
- **画像アップロード**: 商品画像管理

### 3.3 除外機能（学習範囲外）
- **決済処理**: 外部決済API連携
- **在庫管理**: リアルタイム在庫管理システム
- **配送管理**: 配送業者API連携
- **高度なセキュリティ**: OAuth、2FA等
- **パフォーマンス最適化**: キャッシュ、CDN等

---

## 4. 非機能要件

### 4.1 性能要件（学習レベル）
- **応答時間**: 通常操作で3秒以内（開発環境基準）
- **同時接続**: 10ユーザー程度の同時アクセス対応
- **データ量**: 商品数1000件、ユーザー数100名程度まで対応

### 4.2 セキュリティ要件（基本レベル）
- **認証**: セッションベース認証（Express Session）
- **パスワード**: bcryptによるハッシュ化
- **入力検証**: 基本的なXSS、SQLインジェクション対策
- **セッション管理**: セッションタイムアウト、適切な破棄

### 4.3 保守性・拡張性要件
- **アーキテクチャ準拠**: クリーンアーキテクチャ4層分離
- **コンポーネント設計**: アトミックデザイン階層構造
- **テスト可能性**: 各層の独立テスト実行可能
- **設定管理**: 環境別設定の外部化

### 4.4 TypeScript品質要件
- **型カバレッジ**: ドメインモデルとAPIインターフェースの90%以上の型定義
- **コンパイル時エラー検出**: ランタイムエラーのコンパイル時の発見
- **型安全性**: ヌル参照、未定義アクセスのコンパイル時検出
- **リファクタリング安全性**: 型システムによる安全なコード変更の保証

### 4.5 学習効果重視の制約
- **技術スタック限定**: TypeScript + Express + EJS + SQLiteに限定
- **複雑性排除**: フレームワーク依存を最小化
- **段階的学習**: 機能追加による段階的拡張可能性
- **可視化重視**: アーキテクチャ図、フロー図による理解促進

---

## 5. 技術選択の理由と制約

### 5.1 技術スタック選択理由

#### 5.1.1 Express.js
- **学習適合性**: 軽量で理解しやすい構造
- **柔軟性**: アーキテクチャパターンの実装自由度
- **実用性**: 実際の開発現場で広く使用される

#### 5.1.2 EJS（Embedded JavaScript）
- **学習曲線**: JavaScriptベースで習得容易
- **アトミックデザイン**: コンポーネント階層実装に適合
- **パフォーマンス**: サーバーサイドレンダリングで高速

#### 5.1.3 SQLite
- **開発効率**: セットアップ不要で学習に集中可能
- **軽量性**: 単一ファイルでの管理
- **移行性**: 将来的なDBMS移行が容易

#### 5.1.4 TypeScript
- **学習価値**: モダンなWeb開発の標準技術で実務価値が高い
- **設計品質向上**: 型システムが強制する設計原則の体験
- **静的解析**: コンパイル時品質チェックによる学習効果
- **ドキュメンテーション効果**: 型定義自体がドキュメンテーションの役割
- **リファクタリング体験**: 型安全性によるコード変更の安全性理解

### 5.2 学習効果重視の技術選定方針
- **フレームワーク依存最小化**: 設計原則の理解を優先
- **実装の可視化**: アーキテクチャの境界を明確化
- **段階的学習**: 複雑性を段階的に追加可能

### 5.3 複雑性排除の方針
- **認証**: OAuth等の外部認証は使用しない
- **ORM**: Sequelize等のORM使用せず、生SQLで実装
- **フロントエンド**: SPA化せず、サーバーサイドレンダリング
- **デプロイ**: 本番デプロイメントは学習範囲外

---

## 6. 前提条件・制約事項

### 6.1 開発環境前提条件
- **Node.js**: v18以上
- **TypeScript**: v5.0以上（グローバルインストール推奨）
- **パッケージマネージャ**: npmまたはyarn
- **OS**: Windows, macOS, Linux対応
- **エディタ**: VSCode推奨（TypeScript、拡張機能によるサポート）
- **ブラウザ**: Chrome, Firefox, Safari最新版対応

### 6.2 学習時間・スキルレベル前提
- **想定学習時間**: 50-75時間（TypeScript学習、設計学習含む）
- **前提スキル**: JavaScript基礎、HTML/CSS基礎、Node.js基本知識、**TypeScript基礎知識**
- **TypeScript前提スキル**: 基本的な型アノテーション、interface、コンパイル操作
- **目標スキルレベル**: 中級開発者レベルの型安全設計能力習得

### 6.3 プロジェクト範囲の制限
- **学習フォーカス**: アーキテクチャ設計と実装に集中
- **機能スコープ**: 基本的なEC機能に限定
- **品質基準**: 商用レベルは要求しない（学習品質で十分）
- **スケジュール**: 学習進度を最優先、期限は柔軟

### 6.4 技術制約
- **データベース**: SQLite単一ファイルDB
- **セッション**: メモリストア（本番用Redis等は使用しない）
- **ファイルストレージ**: ローカルファイルシステム
- **外部API**: 最小限（学習必要分のみ）

---

## 7. 用語集・略語定義

### 7.1 アーキテクチャ関連用語

| 用語 | 定義 |
|------|------|
| **クリーンアーキテクチャ** | Robert C. Martinが提唱した、依存関係逆転原理に基づく4層アーキテクチャ |
| **依存関係逆転** | 上位層（ドメイン）が下位層（インフラ）に依存しない設計原則 |
| **関心の分離** | 異なる責務を持つコードを独立したモジュールに分離する原則 |
| **Presentation Layer** | HTTPリクエスト処理、UI表示を担う最外層 |
| **Application Layer** | ビジネスフローの調整、トランザクション境界を管理する層 |
| **Domain Layer** | ビジネスルール、エンティティを含むコア層 |
| **Infrastructure Layer** | データベース、外部サービスとの連携を担う層 |

### 7.2 アトミックデザイン関連用語

| 用語 | 定義 |
|------|------|
| **アトミックデザイン** | Brad Frostが提唱したUIコンポーネント設計手法 |
| **Atoms（原子）** | ボタン、入力フィールド等の最小単位コンポーネント |
| **Molecules（分子）** | 検索フォーム等、Atomsを組み合わせた機能単位 |
| **Organisms（有機体）** | ヘッダー、商品リスト等の複雑なUI領域 |
| **Templates（テンプレート）** | ページレイアウトの骨格定義 |
| **Pages（ページ）** | 実際のコンテンツが配置された完成ページ |

### 7.3 技術・実装関連用語

| 用語 | 定義 |
|------|------|
| **MVC** | Model-View-Controller設計パターン |
| **Entity** | ビジネスデータとルールを持つドメインオブジェクト |
| **UseCase** | 特定のビジネス機能を実現するアプリケーション層のクラス |
| **Repository** | データアクセスを抽象化するデザインパターン |
| **Value Object** | 値そのもので識別される不変オブジェクト |
| **Domain Service** | 複数Entityにまたがるビジネスルールを実装するサービス |

### 7.4 TypeScript・型システム関連用語

| 用語 | 定義 |
|------|---------|
| **TypeScript** | Microsoftが開発したJavaScriptのスーパーセット言語、静的型付けを提供 |
| **Interface** | オブジェクトの形状を定義する契約、実装を約束する抽象化 |
| **Type Annotation** | 変数、関数の引数、戻り値に型を明示する記法 |
| **Generic型** | 型パラメータを受け取る、再利用可能な型定義 |
| **Union型** | 複数の型のうちいずれかを表す型（A \| B） |
| **Intersection型** | 複数の型を結合した型（A & B） |
| **Utility Types** | TypeScript組み込みの汎用的な型操作ユーティリティ |
| **Type Guard** | 実行時に型を絞り込むメカニズム |
| **型推論** | 明示的な型アノテーションなしで型を自動判定する機能 |
| **型安全性** | コンパイル時に型エラーを検出し、ランタイムエラーを防ぐ特性 |
| **Nominal Typing** | 型の名前で同一性を判定する型システム |
| **Structural Typing** | 型の構造で同一性を判定するTypeScriptの型システム |

### 7.5 略語定義

| 略語 | 正式名称 | 意味 |
|------|----------|------|
| **CA** | Clean Architecture | クリーンアーキテクチャ |
| **AD** | Atomic Design | アトミックデザイン |
| **DI** | Dependency Injection | 依存性注入 |
| **IoC** | Inversion of Control | 制御の反転 |
| **SRP** | Single Responsibility Principle | 単一責任原則 |
| **OCP** | Open/Closed Principle | オープン/クローズド原則 |
| **LSP** | Liskov Substitution Principle | リスコフの置換原則 |
| **ISP** | Interface Segregation Principle | インターフェース分離原則 |
| **DIP** | Dependency Inversion Principle | 依存関係逆転原則 |
| **TS** | TypeScript | TypeScript |
| **TDD** | Type Driven Development | 型駆動開発 |

---

## 付録

### A. 参考資料
- Clean Architecture: Robert C. Martin著
- Atomic Design: Brad Frost著
- TypeScript Handbook: Microsoft公式ドキュメント
- Express.js公式ドキュメント
- EJSテンプレートエンジン仕様書
- プログラミングTypeScript: Boris Cherny著

### B. 関連文書
- `business-flows.md`: 業務フロー図とアーキテクチャ対応表
- `02_設計書.md`: 詳細設計書（予定）
- `03_実装ガイド.md`: 実装手順書（予定）

---

**承認者**: [学習者名]
**承認日**: [承認日付]
**次回レビュー**: 設計書作成後